# -*- coding: utf-8 -*-
"""pbakare_DIAML_Assignment3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/121m4aFAa9-7-9v1CwNA2j49Q-cDHmYaC
"""

import numpy as peacenp
from scipy import stats as peacestats
from tabulate import tabulate
import math
import pandas as peacepd
import matplotlib.pyplot as peaceplt
from statsmodels.graphics.tsaplots import plot_acf
import statsmodels.api as sm

"""# **QUESTION 1**

Daily energy intake in kJ was measured for 11 women (Altman, 1991):
5260, 5470, 5640, 6180, 6390, 6515, 6805, 7515, 7515, 8230, 8770.
We wish to investigate whether the women’s energy intake deviates
systematically from a recommended value of 7725 kJ. Assuming this
data comes from a normal distribution; use a t-test to test whether the
distribution might have a mean of 7725 kJ. Explain whether a left-tail,
right-tail or two-tailed test is appropriate. Give the sample mean, sample
standard deviation, standard error of the mean (SEM), t statistic, degrees
of freedom and p-value. Finally explain if the null hypothesis is rejected
or not.

Null and Alternative Hypothesis

Null hypothesis H0: μ = 7725 kJ

Alternative hypothesis H1: μ ≠ 7725 kJ
"""

women_energy = peacenp.array([5260, 5470, 5640, 6180, 6390, 6515, 6805, 7515, 7515, 8230, 8770])

# Representing the Null hypothesis H0: μ as
H0 = 7725

mean_of_sample = peacenp.mean(women_energy)
print(mean_of_sample)

standard_deviation_of_sample = peacenp.std(women_energy, ddof=1)
print(standard_deviation_of_sample)

standard_error_mean = standard_deviation_of_sample / peacenp.sqrt(len(women_energy))
print(standard_error_mean)

# Calculate the degrees of freedom
degrees_of_freedom = len(women_energy) - 1
print(degrees_of_freedom)

# Calculate the t-statistics
t_statistics = (mean_of_sample - H0) / standard_error_mean
print(t_statistics)

# Calculate the p-value
p_value = peacestats.t.sf(peacenp.abs(t_statistics), degrees_of_freedom) * 2
print(p_value)

# Function to present the Statistics Summary
def summary_statistics(a, b, c, d, e, f):
  summary = [
      ['Sample Mean', a],
      ['Sample Standard Deviation', b],
      ['Standard Error of the Mean', c],
      ['t-statistics', d],
      ['Degrees of Freedom', e],
      ['p_value', f ]
  ]
  return summary

stats_summary = summary_statistics(mean_of_sample, standard_deviation_of_sample, standard_error_mean, t_statistics, degrees_of_freedom, p_value)
print(tabulate(stats_summary, headers=["Statistic", "Value"], tablefmt='github'))

"""# **QUESTION 2**

A Guinness Overall Enjoyment Score (GOES) was used to test if
Guinness served in an Irish pub tastes significantly better than pints
served elsewhere around the globe. Pints consumed in Ireland received a
mean GOES score of 74, while the average GOES score for Guinness
tasted elsewhere was 57. The full results were as follows:

![image.png](data:image/png;base64,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)

Is this difference of 74 versus 57 significant, or is it simply due to
natural, random variation? Use a t-test and explain whether a
one-sample, two-sample or paired test is appropriate. Show the steps of
calculating the t statistic and explain whether a left-tailed, right-tailed or
two-tailed test is required. Give the resulting p-value.
"""

mean_for_ireland = 74
mean_for_elsewhere = 57
standard_deviation_ireland = 7.4
standard_deviation_elsewhere = 7.1
sample_size_ireland = 42
sample_size_elsewhere = 61

# Calculate degrees of freedom
numerator = ((standard_deviation_ireland ** 2 / sample_size_ireland) + (standard_deviation_elsewhere ** 2 / sample_size_elsewhere)) ** 2
denominator = ((standard_deviation_ireland ** 2 / sample_size_ireland) ** 2 / (sample_size_ireland - 1)) + ((standard_deviation_elsewhere ** 2 / sample_size_elsewhere) ** 2 / (sample_size_elsewhere - 1))
degrees_of_freedom = numerator / denominator
print(degrees_of_freedom)

# Calculate t-statistic
t_statistic = (mean_for_ireland - mean_for_elsewhere) / math.sqrt((standard_deviation_ireland ** 2 / sample_size_ireland) + (standard_deviation_elsewhere ** 2 / sample_size_elsewhere))
print(t_statistic)

# Calculate the two-tailed p-value
p_value = 2 * peacestats.t.sf(peacenp.abs(t_statistic), df=degrees_of_freedom)
print(p_value)

# Function to present the Statistics Summary
def summary_statistics(a, b, c):
  summary = [
      ['Degrees of Freedom', a],
      ['t-statistic', b],
      ['p_value', c]
  ]
  return summary

stats2_summary = summary_statistics(degrees_of_freedom, t_statistic, p_value)
print(tabulate(stats2_summary, headers=["Statistic", "Value"], tablefmt='github'))

"""# **QUESTION 3**

Use data from the World Bank Indicators for 2013 to study the
relationship between Fertility rate, total (births per woman) versus GDP
per capita PPP (current international $). Make a carefully labelled
graph with one dot per country. Estimate the correlation coefficient and
give your interpretation.
"""

df_GDP_data = peacepd.read_csv('/API_NY.GDP.PCAP.PP.CD_DS2_en_csv_v2_31760.csv', skiprows=4)
df_fertility_data = peacepd.read_csv('/API_SP.DYN.TFRT.IN_DS2_en_csv_v2_1890.csv', skiprows=4)

df_GDP_data.head()

df_fertility_data.head()

df_GDP_data = df_GDP_data[['Country Name', '2013']]
df_fertility_data = df_fertility_data[['Country Name', '2013']]

df_GDP_data.head()

df_fertility_data.head()

# Rename columns
df_GDP_data.columns = ['Country', '2013 GDP per capita']
df_fertility_data.columns = ['Country', '2013 Fertility rate']

df_merged_data = peacepd.merge(df_GDP_data, df_fertility_data, on='Country', how='inner')

df_merged_data = df_merged_data.dropna()

# Make Scatter Plot
peaceplt.figure(figsize=(10, 6))
peaceplt.scatter(df_merged_data['2013 GDP per capita'], df_merged_data['2013 Fertility rate'], color='blue')

# Label the axes and title the plot
peaceplt.xlabel('GDP per capita (PPP, current international $)')
peaceplt.ylabel('Fertility Rate (births per woman)')
peaceplt.title('Fertility Rate vs. GDP per Capita (2023)')
peaceplt.legend(['Countries'])

peaceplt.show()

correlation = peacenp.corrcoef(df_merged_data['2013 GDP per capita'], df_merged_data['2013 Fertility rate'])[0, 1]
correlation

"""# **QUESTION 4**

Load in monthly average house price data in pounds sterling (£) from
Jan 1991 to Dec 2016. Download the data from canvas. (choose the file
UK monthly indices (Post ‘91)). Graph the time series and label it
carefully. Construct the autocorrelation function (ACF) of the monthly
returns defined as r(t) = [p(t)/p(t-1)]-1 and show the values for lags of
one up to 20 using a bar graph. Indicate the values of the ACF using
horizontal lines that would correspond to a statistically significant result
at p<0.05. From the ACF of monthly data is there evidence of
seasonality? Is there a trend in the time series? What is the annualized
return over this period as a percentage?
"""

df_house_price = peacepd.read_excel('/Monthly Average House Price.xls')

df_house_price.head()

df_house_price = df_house_price.rename(columns={'Unnamed: 0' : 'Date'})

df_house_price.head()

#df_house_price['Date'] = peacepd.to_datetime(df_house_price['Date'])

df_house_price = df_house_price[df_house_price['Date'].dt.year <= 2016]

peaceplt.figure(figsize=(10, 6))
peaceplt.plot(df_house_price['Date'], df_house_price['Average House Price'], color='blue')
peaceplt.xlabel('Year')
peaceplt.ylabel('Average House Price')
peaceplt.title('UK Monthly Average House Price (1991 - 2016)')
peaceplt.legend(['Average House Price'])
peaceplt.grid(True)
peaceplt.show()

# Calculate the monthly returns using the formula
df_house_price.loc[:, 'Monthly Return'] = (df_house_price['Average House Price'] / df_house_price['Average House Price'].shift(1)) - 1

df_house_price.head()

monthly_return = df_house_price['Monthly Return']

acf_data = sm.tsa.stattools.acf(df_house_price['Monthly Return'].dropna(), nlags=20)

peaceplt.figure(figsize=(10, 6))
peaceplt.bar(range(len(acf_data)-1), acf_data[1:], color='blue')
peaceplt.axhline(y=1.96/peacenp.sqrt(len(df_house_price['Monthly Return'].dropna())), color='red', linestyle='--', label='Upper confidence Interval')
peaceplt.axhline(y=-1.96/peacenp.sqrt(len(df_house_price['Monthly Return'].dropna())), color='green', linestyle='--', label='Lower Confidence Level')
peaceplt.title('Monthly Autocorrelation Function (ACF)')
peaceplt.xlabel('Lags')
peaceplt.ylabel('ACF Value')
peaceplt.legend()
peaceplt.grid(True)
peaceplt.show()

# Calculate the annualized return
initial_house_price = df_house_price['Average House Price'].iloc[0]
final_house_price = df_house_price['Average House Price'].iloc[-1]

# Calculate the number of years
days_to_years = ((df_house_price['Date'].iloc[-1]) - (df_house_price['Date'].iloc[0])).days / 365.25
#years = (df_house_price['Date'].iloc[-1]) - (df_house_price['Date'].iloc[0])
#number_of_years = month_to_years + years
print(days_to_years)

# Annualized return formula
annualized_return_house_prices = ((final_house_price / initial_house_price) ** (1 / days_to_years)) - 1
annualized_return_percentage_house_prices = annualized_return_house_prices * 100

print(annualized_return_percentage_house_prices)

"""# **QUESTION 5**

Load in the FTSE100 index from canvas (ticker = ^FTSE) over the
same period (01-Jan-1991 to 31-Dec-2016). Plot the cumulative returns
from the House market (using the price data from question 4) and the
FTSE100 index on the same graph with the time series normalized such
that each starts at 100 in Jan-1991. What is the average annualized
return from the FTSE100? Would it have been better to invest in a UK
house or the UK stock market over this period?
"""

df_ftse_data = peacepd.read_csv('/FTSE100.csv')

df_ftse_data.head()

df_ftse_data.tail()

df_ftse_data['Date'] = peacepd.to_datetime(df_ftse_data['Date'])

# Filter for dates between January 1, 1991 and December 31, 2016 for FTSE data
start_date = '1991-01-01'
end_date = '2016-12-31'
df_ftse_data = df_ftse_data[(df_ftse_data['Date'] >= start_date) & (df_ftse_data['Date'] <= end_date)]

df_ftse_sorted = df_ftse_data.sort_values(by='Date')
#, ascending=True).reset_index(drop=False)

df_ftse_sorted

df_house_price.head()

# Filter for dates between January 1, 1991 and December 31, 2016 for UK House data
df_house_price = df_house_price[(df_house_price['Date'] >= start_date) & (df_house_price['Date'] <= end_date)]

# df_ftse_data['Return'] = (df_ftse_data['Close'] / df_ftse_data['Close'].shift(1)) - 1
# df_house_price['Return'] = (df_house_price['Average House Price'] / df_house_price['Average House Price'].shift(1)) - 1

# Calculate returns for df_ftse_data
df_ftse_sorted.loc[:, 'Return'] = (df_ftse_sorted['Close'] / df_ftse_sorted['Close'].shift(1)) - 1

# Calculate returns for df_house_price
df_house_price.loc[:, 'Return'] = (df_house_price['Average House Price'] / df_house_price['Average House Price'].shift(1)) - 1

# Drop NaN values
#df_ftse_sorted = df_ftse_sorted.dropna()
#df_house_price = df_house_price.dropna()

# Calculate the cumulative returns for both datasets
df_ftse_sorted.loc[:, 'Cumulative Return'] = (df_ftse_sorted['Return']).cumsum()
df_house_price.loc[:, 'Cumulative Return'] = (df_house_price['Monthly Return']).cumsum()

# Normalize the cumulative returns to start 100 in January 1991
df_ftse_sorted.loc[:, 'Normalized Return'] = 100 * (df_ftse_sorted['Cumulative Return'] / df_ftse_sorted['Cumulative Return'].iloc[1])
df_house_price.loc[:, 'Normalized Return'] = 100 * (df_house_price['Cumulative Return'] / df_house_price['Cumulative Return'].iloc[1])

# Plot the normalized cumulative returns for both FTSE100 and UK House prices
peaceplt.figure(figsize=(10, 6))
peaceplt.plot(df_ftse_sorted['Date'], df_ftse_sorted['Normalized Return'], label='FTSE100', color='blue')
peaceplt.plot(df_house_price['Date'], df_house_price['Normalized Return'], label='UK House', color='red')
peaceplt.xlabel('Year')
peaceplt.ylabel('Normalized Cumulative Return (Starting at 100)')
peaceplt.title('Normalized Cumulative Returns for FTSE100 and UK House Prices')
peaceplt.legend(loc='upper left')
peaceplt.grid(True)
peaceplt.show()

df_ftse_sorted

# Calculate the annualized return for FTSE100
initial_price_ftse = df_ftse_sorted['Close'].iloc[0]
final_price_ftse = df_ftse_sorted['Close'].iloc[-1]
days_to_years_ftse = ((df_ftse_sorted['Date'].iloc[-1]) - (df_ftse_sorted['Date'].iloc[0])).days / 365.25
#years_ftse = (df_ftse_sorted['Date'].iloc[-1]).year - (df_ftse_sorted['Date'].iloc[0].year)

#number_of_years_ftse = month_to_years_ftse + years_ftse
print(days_to_years_ftse)

df_annualized_return_ftse = ((final_price_ftse / initial_price_ftse) ** (1 / days_to_years_ftse)) - 1
df_annualized_return_ftse_percentage = df_annualized_return_ftse * 100

# Print the annualized returns of UK House Prices and FTSE for comparison
print("Annualized Return for UK House Prices:", annualized_return_percentage_house_prices)
print("Annualized Return for FTSE100:", df_annualized_return_ftse_percentage)

